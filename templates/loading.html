<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>the wavelength app</title>
    <link rel="stylesheet" href="static/styles.css">
    <link rel="stylesheet" href="static/loading.css">
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- <link rel="icon" href="../static/icons/Mock_Logo.png" type="image/png"> -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script>

        function add_text() {
            document.getElementById('change_text').textContent = "Awesome, we're all done. Let's take a look!";
            document.body.style.opacity = '0';
        }

        $(document).ready(function() {
            $.ajax({
                url: '/fetch_data',
                type: 'GET',
                success: function(response) {
                    // Assuming the AJAX call to /fetch_data stores data in the session and
                    // returns a success signal
                    if(response.success) {
                        add_text();
                        // Redirect to the display page
                        setTimeout(function() {
                            window.location.href = "/display"; // Redirect to the page where data will be displayed
                        }, 500); // Delay in milliseconds (2000ms = 2 seconds)
                    }
                },
                error: function(error) {
                    console.log(error);
                }
            });
        });
    </script>
</head>
<body>
    <header>
        <h3 id="home-nav">wavelength</h3>
        <img src="../static/icons/menu.png" alt="Navigation Bars">
    </header>
    <script>
        // This code assumes you've given your <header> an id of "clickableHeader"
        document.getElementById('home-nav').addEventListener('click', function() {
            window.location.href = '/';
        });
    </script>
    <div id="center-block">
        <h1>Wow, you've got good taste.</h1>
        <p id="change_text">Give us a second to take it all in.</p>
    </div>
    <svg id="lineGraph"></svg>
    <svg id="graphic"></svg>
    <script>
        const datasets = [
            [
                {x: 0, y: 10}, {x: 1, y: 10}, {x: 2, y: -20}, {x: 2.5, y: 30},
                {x: 3, y: 50}, {x: 4, y: 20}, {x: 5, y: -10}, 
                {x: 6, y: 30}, {x: 7, y: 15}, {x: 8, y: 15}
            ],
            [
                {x: 0, y: 25}, {x: 1, y: -20}, {x: 2, y: 10}, {x: 2.5, y: -30},
                {x: 3, y: 15}, {x: 4, y: 60}, {x: 5, y: 0}, 
                {x: 6, y: 45}, {x: 7, y: 10}, {x: 8, y: 20}
            ],
            [
                {x: 0, y: 5}, {x: 1, y: 35}, {x: 2, y: 0}, {x: 2.5, y: 25},
                {x: 3, y: 50}, {x: 4, y: 10}, {x: 5, y: -40}, 
                {x: 6, y: 15}, {x: 7, y: 30}, {x: 8, y: 20}
            ],
            [
                {x: 0, y: 10}, {x: 1, y: 20}, {x: 2, y: 30}, {x: 2.5, y: 5},
                {x: 3, y: -20}, {x: 4, y: 45}, {x: 5, y: 15}, 
                {x: 6, y: 60}, {x: 7, y: 25}, {x: 8, y: 30}
            ]
        ];


    
        let currentDatasetIndex = 0;
    
        function drawGraph() {
            const svgElement = document.getElementById('lineGraph');
            const width = svgElement.clientWidth;
            const height = svgElement.clientHeight;
            const svg = d3.select(svgElement).attr("viewBox", `0 0 ${width} ${height}`).attr("preserveAspectRatio", "xMidYMid meet");
    
            const margin = {top: 20, right: 20, bottom: 20, left: 20},
                graphWidth = width - margin.left - margin.right,
                graphHeight = height - margin.top - margin.bottom;
    
            svg.selectAll("*").remove(); // Clear any previous graph
    
            const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
    
            // Setup the scales
            const xScale = d3.scaleLinear().domain([0, d3.max(datasets[0], d => d.x)]).range([0, graphWidth]);
            let allYValues = datasets.flat().map(d => d.y); // Flatten all y values across datasets
            const yScale = d3.scaleLinear().domain([d3.min(allYValues), d3.max(allYValues)]).range([graphHeight, 0]);
    
            // Line generator
            const line = d3.line()
                            .x(d => xScale(d.x))
                            .y(d => yScale(d.y))
                            .curve(d3.curveBasis);
    
            // Initialize path with first dataset
            const path = g.append("path")
                          .datum(datasets[0])
                          .attr("fill", "none")
                          .attr("stroke", "white")
                          .attr("stroke-width", 5)
                          .attr("d", line);
    
            function updateGraph(datasetIndex) {
                // Calculate new Y scale based on the new dataset
                yScale.domain([d3.min(allYValues), d3.max(allYValues)]).range([graphHeight, 0]);
    
                // Apply the new data and transition
                path.datum(datasets[datasetIndex % datasets.length])
                    .transition()
                    .duration(2000)
                    .attr("d", line);
            }
    
            setTimeout(() => {
                updateGraph(++currentDatasetIndex);
            }, 0); // Set timeout to 0 to immediately invoke without delay

            // Continue updating the graph at regular intervals
            setInterval(() => {
                updateGraph(++currentDatasetIndex);
            }, 2000);
        }
    
        drawGraph();
        window.addEventListener('resize', drawGraph);
    </script>    
<script>
    // Correctly define margins before using them
    const margin = {top: 20, right: 20, bottom: 20, left: 20};

    // Correct the SVG container selection and sizing
    const svg = d3.select("#graphic");
    const svgDom = document.getElementById('graphic'); // Correct variable name used below
    const width = svgDom.clientWidth - margin.left - margin.right;
    const height = svgDom.clientHeight - margin.top - margin.bottom;

    // Correctly append 'g' after defining margins
    const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

    const data = [
        { x: 1, y: 5.5 }, { x: 2, y: 6 }, { x: 3, y: 4 },
        { x: 4, y: 5 }, { x: 5, y: 6 }, { x: 6, y: 1.5 },
        { x: 7, y: 6}, { x: 8, y: 5.5 },
    ];

    const newData = [
        { x: 1, y: 5 }, { x: 2, y: 6 }, { x: 3, y: 6 },
        { x: 4, y: 4 }, { x: 5, y: 3 }, { x: 6, y: 3 },
        { x: 7, y: 2}, { x: 8, y: 2.5 }
    ];

    // Correct the scales to use final graph dimensions
    const x = d3.scaleLinear()
                .domain(d3.extent([...data, ...newData], d => d.x))
                .range([0, width]);

    const y = d3.scaleLinear()
                .domain([0, d3.max([...data, ...newData], d => d.y)])
                .range([height, 0]);

    // Ensure SVG is set to be responsive
    svg.attr("viewBox", `0 0 ${width + margin.left + margin.right} ${height + margin.top + margin.bottom}`)
       .attr("preserveAspectRatio", "xMidYMid meet");

    // Data sets
    

    // Define gradients before using them in paths
    const defs = svg.append("defs");

    const gradient1 = defs.append("linearGradient")
        .attr("id", "line-gradient")
        .attr("gradientUnits", "userSpaceOnUse")
        .attr("x1", 0).attr("y1", y(0))
        .attr("x2", 0).attr("y2", y(d3.max([...data, ...newData], d => d.y)));

    gradient1.selectAll("stop")
        .data([
            {offset: "80%", color: "#FF8934"},
            {offset: "100%", color: "rgba(255, 137, 52, .4)"}
        ])
        .enter().append("stop")
        .attr("offset", d => d.offset)
        .attr("stop-color", d => d.color);

    // Assuming the calculations for gradient2's positions are done prior
    const gradient2 = defs.append("linearGradient")
        .attr("id", "line-gradient1")
        .attr("gradientUnits", "userSpaceOnUse")
        .attr("x1", 0) // Correct these values based on your gradient direction and length
        .attr("y1", height)
        .attr("x2", width)
        .attr("y2", 0);

    gradient2.selectAll("stop")
        .data([
            {offset: "0%", color: "rgba(255,255,255, 1)"}, // Starting color
            {offset: "5%", color: "rgba(241, 140, 231, 1)"} // Fading to transparent
        ])
        .enter().append("stop")
        .attr("offset", d => d.offset)
        .attr("stop-color", d => d.color);

    

    // Area generator
    const area = d3.area()
                   .x(d => x(d.x))
                   .y0(height)
                   .y1(d => y(d.y))
                   .curve(d3.curveBasis);

    // Append areas for both datasets
    g.append("path")
        .datum(data)
        .attr("fill", "url(#line-gradient1)")
        .attr("d", area);

    g.append("path")
        .datum(newData)
        .attr("fill", "url(#line-gradient)")
        .attr("d", area)
        .attr("opacity", "0.9");
</script>

        
</body>
</html>